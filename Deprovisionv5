# Cloud PC Recovery & Reprovisioning Tool - Automated Version - PART 1 OF 3
# Requires Microsoft.Graph PowerShell Module
#
# USAGE EXAMPLES:
# ===============
#
# Interactive Mode (default):
# .\CloudPCTool.ps1
# .\CloudPCTool.ps1 -Operation Interactive
#
# View all provisioning policies:
# .\CloudPCTool.ps1 -Operation ViewPolicies
#
# View all Azure Network Connections:
# .\CloudPCTool.ps1 -Operation ViewNetworkConnections
#
# Export network connections to CSV:
# .\CloudPCTool.ps1 -Operation ViewNetworkConnections -Silent > network_connections.csv
#
# Check Cloud PC status for single user:
# .\CloudPCTool.ps1 -Operation CheckStatus -UserPrincipalName user@domain.com
#
# Check status for multiple users from array:
# .\CloudPCTool.ps1 -Operation CheckStatus -UserList user1@domain.com,user2@domain.com,user3@domain.com
#
# Check status for users from CSV file:
# .\CloudPCTool.ps1 -Operation CheckStatus -UserListFile "C:\users.csv"
#
# Deprovision single user with confirmations:
# .\CloudPCTool.ps1 -Operation DeprovisionSingle -UserPrincipalName user@domain.com
#
# Deprovision single user automatically (no prompts):
# .\CloudPCTool.ps1 -Operation DeprovisionSingle -UserPrincipalName user@domain.com -AutoConfirm -AutoEndGracePeriod
#
# Bulk deprovision from CSV file with auto-confirmation:
# .\CloudPCTool.ps1 -Operation DeprovisionBulk -UserListFile "C:\users.csv" -AutoConfirm -AutoEndGracePeriod
#
# Bulk deprovision from CSV file silently (no console output):
# .\CloudPCTool.ps1 -Operation DeprovisionBulk -UserListFile "C:\users.csv" -AutoConfirm -AutoEndGracePeriod -Silent
#
# Bulk deprovision from user list array:
# .\CloudPCTool.ps1 -Operation DeprovisionBulk -UserList user1@domain.com,user2@domain.com -AutoConfirm
#
# Move user to specific policy (auto-discovery of current policy):
# .\CloudPCTool.ps1 -Operation MoveUserAuto -UserPrincipalName user@domain.com -TargetPolicyName "Standard Policy"
#
# End grace period for user's Cloud PC:
# .\CloudPCTool.ps1 -Operation EndGracePeriod -UserPrincipalName user@domain.com
#
# Monitor Cloud PC provisioning with custom timeout:
# .\CloudPCTool.ps1 -Operation MonitorProvisioning -UserPrincipalName user@domain.com -TimeoutMinutes 45
#
# Using app-only authentication:
# .\CloudPCTool.ps1 -Operation ViewPolicies -TenantId "tenant-id" -ClientId "app-id" -ClientSecret "secret"
#
# CSV FILE FORMAT:
# ================
# The CSV file should contain user email addresses in one of these column formats:
# - Column named: UPN, UserPrincipalName, Email, User Principal Name
# - If no recognized column, the first column will be used
# 
# Example CSV content:
# UPN
# user1@domain.com
# user2@domain.com
# user3@domain.com
#
# TEXT FILE FORMAT:
# =================
# Simple text file with one email address per line:
# user1@domain.com
# user2@domain.com
# user3@domain.com

param(
    [Parameter(Mandatory=$false)]
    [string]$TenantId,
    
    [Parameter(Mandatory=$false)]
    [string]$ClientId,
    
    [Parameter(Mandatory=$false)]
    [string]$ClientSecret,
    
    # Automation parameters
    [Parameter(Mandatory=$false)]
    [ValidateSet("ViewPolicies", "ViewNetworkConnections", "MoveUser", "MoveUserAuto", "CheckStatus", "EndGracePeriod", "MonitorProvisioning", "CompleteRecovery", "DeprovisionSingle", "DeprovisionBulk", "Interactive")]
    [string]$Operation = "Interactive",
    
    [Parameter(Mandatory=$false)]
    [string]$UserPrincipalName,
    
    [Parameter(Mandatory=$false)]
    [string]$UserListFile,
    
    [Parameter(Mandatory=$false)]
    [string[]]$UserList,
    
    [Parameter(Mandatory=$false)]
    [string]$SourcePolicyName,
    
    [Parameter(Mandatory=$false)]
    [string]$TargetPolicyName,
    
    [Parameter(Mandatory=$false)]
    [switch]$AutoEndGracePeriod,
    
    [Parameter(Mandatory=$false)]
    [switch]$AutoConfirm,
    
    [Parameter(Mandatory=$false)]
    [int]$TimeoutMinutes = 30,
    
    [Parameter(Mandatory=$false)]
    [switch]$Silent
)

# Import required modules
Import-Module Microsoft.Graph.Authentication -ErrorAction Stop
Import-Module Microsoft.Graph.Groups -ErrorAction Stop
Import-Module Microsoft.Graph.DeviceManagement.Administration -ErrorAction Stop

# Global variables
$Global:AuthenticationMethod = $null
$Global:ConnectedToGraph = $false
$Global:SilentMode = $Silent

# Function to write output (respects silent mode)
function Write-Output-Safe {
    param(
        [string]$Message,
        [string]$ForegroundColor = "White"
    )
    
    if (-not $Global:SilentMode) {
        if ($ForegroundColor -ne "White") {
            Write-Host $Message -ForegroundColor $ForegroundColor
        } else {
            Write-Host $Message
        }
    }
}

# Function to display banner
function Show-Banner {
    if (-not $Global:SilentMode) {
        Clear-Host
        Write-Host "================================================" -ForegroundColor Cyan
        Write-Host "   Cloud PC Recovery & Reprovisioning Tool    " -ForegroundColor Yellow
        Write-Host "   Automated Mode                              " -ForegroundColor Green
        Write-Host "================================================" -ForegroundColor Cyan
        Write-Host ""
    }
}

# Function to authenticate to Microsoft Graph
function Connect-ToMicrosoftGraph {
    param(
        [string]$TenantId,
        [string]$ClientId,
        [string]$ClientSecret
    )
    
    try {
        Write-Output-Safe "Connecting to Microsoft Graph..." -ForegroundColor Yellow
        
        if ($TenantId -and $ClientId -and $ClientSecret) {
            # App-only authentication
            $secureSecret = ConvertTo-SecureString $ClientSecret -AsPlainText -Force
            $credential = New-Object System.Management.Automation.PSCredential($ClientId, $secureSecret)
            Connect-MgGraph -TenantId $TenantId -ClientSecretCredential $credential -NoWelcome
            $Global:AuthenticationMethod = "App-only"
        } else {
            # Interactive authentication
            Connect-MgGraph -Scopes "DeviceManagementConfiguration.ReadWrite.All","Group.ReadWrite.All","Directory.Read.All","CloudPC.ReadWrite.All" -NoWelcome
            $Global:AuthenticationMethod = "Interactive"
        }
        
        $Global:ConnectedToGraph = $true
        Write-Output-Safe "Successfully connected to Microsoft Graph using $($Global:AuthenticationMethod) authentication" -ForegroundColor Green
        Write-Output-Safe ""
        return $true
    }
    catch {
        Write-Output-Safe "Failed to connect to Microsoft Graph: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to load users from CSV file
function Get-UsersFromFile {
    param([string]$FilePath)
    
    try {
        if (-not (Test-Path $FilePath)) {
            Write-Output-Safe "Error: File not found: $FilePath" -ForegroundColor Red
            return $null
        }
        
        $extension = [System.IO.Path]::GetExtension($FilePath).ToLower()
        
        if ($extension -eq ".csv") {
            $csvData = Import-Csv $FilePath
            
            # Try to find UPN column (common variations)
            $upnColumn = $null
            $headers = $csvData[0].PSObject.Properties.Name
            
            foreach ($header in $headers) {
                if ($header -match "UPN|UserPrincipalName|Email|User.*Principal.*Name" -or $header -ieq "upn" -or $header -ieq "email") {
                    $upnColumn = $header
                    break
                }
            }
            
            if (-not $upnColumn) {
                # If no UPN column found, assume first column
                $upnColumn = $headers[0]
                Write-Output-Safe "Warning: No UPN column found. Using first column: $upnColumn" -ForegroundColor Yellow
            }
            
            $users = $csvData | ForEach-Object { $_.$upnColumn } | Where-Object { $_ -and $_.Trim() }
            Write-Output-Safe "Loaded $($users.Count) users from CSV file using column: $upnColumn" -ForegroundColor Green
            return $users
        }
        elseif ($extension -eq ".txt") {
            $users = Get-Content $FilePath | Where-Object { $_ -and $_.Trim() }
            Write-Output-Safe "Loaded $($users.Count) users from text file" -ForegroundColor Green
            return $users
        }
        else {
            Write-Output-Safe "Error: Unsupported file format. Use .csv or .txt files" -ForegroundColor Red
            return $null
        }
    }
    catch {
        Write-Output-Safe "Error reading file: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

# Function to get all Windows 365 provisioning policies
function Get-CloudPCProvisioningPolicies {
    try {
        Write-Output-Safe "Retrieving Windows 365 Provisioning Policies..." -ForegroundColor Yellow
        
        $uri = "https://graph.microsoft.com/beta/deviceManagement/virtualEndpoint/provisioningPolicies"
        $policies = Invoke-MgGraphRequest -Uri $uri -Method GET
        
        if ($policies.value.Count -eq 0) {
            Write-Output-Safe "No provisioning policies found" -ForegroundColor Yellow
            return $null
        }
        
        Write-Output-Safe "Found $($policies.value.Count) provisioning policies:" -ForegroundColor Green
        
        $policyList = @()
        foreach ($policy in $policies.value) {
            Write-Output-Safe "  Processing policy: $($policy.displayName)..." -ForegroundColor Gray
            
            $policyInfo = [PSCustomObject]@{
                Id = $policy.id
                DisplayName = $policy.displayName
                Description = $policy.description
                ImageDisplayName = $policy.imageDisplayName
                DomainJoinType = if ($policy.domainJoinConfigurations -and $policy.domainJoinConfigurations.Count -gt 0) { $policy.domainJoinConfigurations[0].domainJoinType } else { "Not specified" }
                Type = $policy.type
                RegionName = if ($policy.domainJoinConfigurations -and $policy.domainJoinConfigurations.Count -gt 0) { $policy.domainJoinConfigurations[0].regionName } else { "Not specified" }
                OnPremisesConnectionId = if ($policy.domainJoinConfigurations -and $policy.domainJoinConfigurations.Count -gt 0) { $policy.domainJoinConfigurations[0].onPremisesConnectionId } else { "Not specified" }
                ProvisioningType = $policy.provisioningType
                ImageType = $policy.imageType
                AssignedGroups = @()
            }
            
            # Get assignments using the correct expand approach
            try {
                Write-Output-Safe "    Retrieving assignments using expand parameter..." -ForegroundColor Gray
                $expandUri = "https://graph.microsoft.com/beta/deviceManagement/virtualEndpoint/provisioningPolicies/$($policy.id)?`$expand=assignments"
                $policyDetails = Invoke-MgGraphRequest -Uri $expandUri -Method GET -ErrorAction Stop
                
                if ($policyDetails.assignments -and $policyDetails.assignments.Count -gt 0) {
                    Write-Output-Safe "    Found $($policyDetails.assignments.Count) assignment(s)" -ForegroundColor Gray
                    
                    foreach ($assignment in $policyDetails.assignments) {
                        Write-Output-Safe "      Processing assignment with target type: $($assignment.target.'@odata.type')" -ForegroundColor Gray
                        
                        if ($assignment.target.'@odata.type' -eq '#microsoft.graph.groupAssignmentTarget' -or 
                            $assignment.target.'@odata.type' -eq '#microsoft.graph.cloudPcManagementGroupAssignmentTarget') {
                            try {
                                $groupId = $assignment.target.groupId
                                Write-Output-Safe "      Getting group details for: $groupId" -ForegroundColor Gray
                                $group = Get-MgGroup -GroupId $groupId -ErrorAction Stop
                                
                                if ($group) {
                                    $policyInfo.AssignedGroups += [PSCustomObject]@{
                                        GroupId = $group.Id
                                        GroupName = $group.DisplayName
                                        GroupType = if ($group.GroupTypes -contains "DynamicMembership") { "Dynamic" } else { "Static" }
                                    }
                                    Write-Output-Safe "      Successfully added group: $($group.DisplayName)" -ForegroundColor Green
                                }
                            }
                            catch {
                                Write-Output-Safe "      Warning: Could not retrieve group $($assignment.target.groupId): $($_.Exception.Message)" -ForegroundColor Yellow
                                $policyInfo.AssignedGroups += [PSCustomObject]@{
                                    GroupId = $assignment.target.groupId
                                    GroupName = "Group not accessible (ID: $($assignment.target.groupId))"
                                    GroupType = "Unknown"
                                }
                            }
                        }
                        elseif ($assignment.target.'@odata.type' -eq '#microsoft.graph.allLicensedUsersAssignmentTarget') {
                            $policyInfo.AssignedGroups += [PSCustomObject]@{
                                GroupId = "AllLicensedUsers"
                                GroupName = "All Licensed Users"
                                GroupType = "Built-in"
                            }
                            Write-Output-Safe "      Added assignment: All Licensed Users" -ForegroundColor Green
                        }
                        elseif ($assignment.target.'@odata.type' -eq '#microsoft.graph.allDevicesAssignmentTarget') {
                            $policyInfo.AssignedGroups += [PSCustomObject]@{
                                GroupId = "AllDevices"
                                GroupName = "All Devices"
                                GroupType = "Built-in"
                            }
                            Write-Output-Safe "      Added assignment: All Devices" -ForegroundColor Green
                        }
                        else {
                            Write-Output-Safe "      Unknown assignment target type: $($assignment.target.'@odata.type')" -ForegroundColor Yellow
                            $policyInfo.AssignedGroups += [PSCustomObject]@{
                                GroupId = if ($assignment.target.groupId) { $assignment.target.groupId } else { "Unknown" }
                                GroupName = "Unknown target type: $($assignment.target.'@odata.type')"
                                GroupType = "Unknown"
                            }
                        }
                    }
                } else {
                    Write-Output-Safe "    No assignments found" -ForegroundColor Gray
                }
            }
            catch {
                Write-Output-Safe "    Warning: Could not retrieve assignments for policy '$($policy.displayName)': $($_.Exception.Message)" -ForegroundColor Yellow
                Write-Output-Safe "    This may be due to insufficient permissions or API limitations" -ForegroundColor Yellow
            }
            
            $policyList += $policyInfo
            Write-Output-Safe "  - $($policy.displayName) (Groups: $($policyInfo.AssignedGroups.Count))" -ForegroundColor White
        }
        
        return $policyList
    }
    catch {
        Write-Output-Safe "Error retrieving provisioning policies: $($_.Exception.Message)" -ForegroundColor Red
        Write-Output-Safe "Full error details: $($_.Exception)" -ForegroundColor Red
        return $null
    }
}

# Function to get all Azure Network Connections (On-Premises Connections)
function Get-AzureNetworkConnections {
    try {
        Write-Output-Safe "Retrieving Azure Network Connections (On-Premises Connections)..." -ForegroundColor Yellow
        
        $uri = "https://graph.microsoft.com/beta/deviceManagement/virtualEndpoint/onPremisesConnections"
        $connections = Invoke-MgGraphRequest -Uri $uri -Method GET
        
        if ($connections.value.Count -eq 0) {
            Write-Output-Safe "No Azure Network Connections found" -ForegroundColor Yellow
            return $null
        }
        
        Write-Output-Safe "Found $($connections.value.Count) network connections:" -ForegroundColor Green
        
        $connectionList = @()
        foreach ($connection in $connections.value) {
            Write-Output-Safe "  Processing connection: $($connection.displayName)..." -ForegroundColor Gray
            
            $connectionInfo = [PSCustomObject]@{
                Id = $connection.id
                DisplayName = $connection.displayName
                SubscriptionId = $connection.subscriptionId
                ConnectionType = $connection.connectionType
                SubscriptionName = $connection.subscriptionName
                AdDomainName = $connection.adDomainName
                AdDomainUsername = $connection.adDomainUsername
                OrganizationalUnit = $connection.organizationalUnit
                ResourceGroupId = $connection.resourceGroupId
                VirtualNetworkId = $connection.virtualNetworkId
                VirtualNetworkLocation = $connection.virtualNetworkLocation
                SubnetId = $connection.subnetId
                HealthCheckStatus = $connection.healthCheckStatus
                HealthCheckStatusDetails = if ($connection.healthCheckStatusDetails) { $connection.healthCheckStatusDetails.displayName } else { "N/A" }
                InUse = $connection.inUse
                ManagedBy = $connection.managedBy
                Type = $connection.type
            }
            
            $connectionList += $connectionInfo
            Write-Output-Safe "  - $($connection.displayName) (Status: $($connection.healthCheckStatus))" -ForegroundColor White
        }
        
        return $connectionList
    }
    catch {
        Write-Output-Safe "Error retrieving Azure Network Connections: $($_.Exception.Message)" -ForegroundColor Red
        Write-Output-Safe "Full error details: $($_.Exception)" -ForegroundColor Red
        return $null
    }
}

# Function to display policies in a formatted table
function Show-ProvisioningPolicies {
    param([array]$Policies)
    
    if (-not $Policies) {
        Write-Output-Safe "No policies to display" -ForegroundColor Yellow
        return
    }
    
    Write-Output-Safe "`nProvisioning Policies and Group Assignments:" -ForegroundColor Cyan
    Write-Output-Safe "============================================================" -ForegroundColor Cyan
    
    for ($i = 0; $i -lt $Policies.Count; $i++) {
        $policy = $Policies[$i]
        Write-Output-Safe "`n[$($i + 1)] $($policy.DisplayName)" -ForegroundColor Yellow
        Write-Output-Safe "    Policy ID: $($policy.Id)" -ForegroundColor Gray
        Write-Output-Safe "    Description: $($policy.Description)" -ForegroundColor Gray
        Write-Output-Safe "    Image: $($policy.ImageDisplayName)" -ForegroundColor Gray
        Write-Output-Safe "    Image Type: $($policy.ImageType)" -ForegroundColor Gray
        Write-Output-Safe "    Domain Join Type: $($policy.DomainJoinType)" -ForegroundColor Gray
        Write-Output-Safe "    Provisioning Type: $($policy.ProvisioningType)" -ForegroundColor Gray
        Write-Output-Safe "    Region: $($policy.RegionName)" -ForegroundColor Gray
        Write-Output-Safe "    Connection ID: $($policy.OnPremisesConnectionId)" -ForegroundColor Gray
        Write-Output-Safe "    Assigned Groups:" -ForegroundColor White
        
        if ($policy.AssignedGroups.Count -eq 0) {
            Write-Output-Safe "      No groups assigned or assignments not accessible" -ForegroundColor Yellow
        } else {
            foreach ($group in $policy.AssignedGroups) {
                Write-Output-Safe "      - $($group.GroupName) ($($group.GroupType))" -ForegroundColor White
                Write-Output-Safe "        Group ID: $($group.GroupId)" -ForegroundColor Gray
            }
        }
    }
}

# Function to display network connections in a formatted table
function Show-NetworkConnections {
    param([array]$Connections)
    
    if (-not $Connections) {
        Write-Output-Safe "No network connections to display" -ForegroundColor Yellow
        return
    }
    
    Write-Output-Safe "`nAzure Network Connections (On-Premises Connections):" -ForegroundColor Cyan
    Write-Output-Safe "================================================================================" -ForegroundColor Cyan
    
    for ($i = 0; $i -lt $Connections.Count; $i++) {
        $connection = $Connections[$i]
        Write-Output-Safe "`n[$($i + 1)] $($connection.DisplayName)" -ForegroundColor Yellow
        Write-Output-Safe "    Connection ID: $($connection.Id)" -ForegroundColor Gray
        Write-Output-Safe "    Subscription ID: $($connection.SubscriptionId)" -ForegroundColor Gray
        Write-Output-Safe "    Subscription Name: $($connection.SubscriptionName)" -ForegroundColor Gray
        Write-Output-Safe "    Connection Type: $($connection.ConnectionType)" -ForegroundColor Gray
        Write-Output-Safe "    AD Domain Name: $($connection.AdDomainName)" -ForegroundColor Gray
        Write-Output-Safe "    AD Domain Username: $($connection.AdDomainUsername)" -ForegroundColor Gray
        Write-Output-Safe "    Organizational Unit: $($connection.OrganizationalUnit)" -ForegroundColor Gray
        Write-Output-Safe "    Resource Group ID: $($connection.ResourceGroupId)" -ForegroundColor Gray
        Write-Output-Safe "    Virtual Network ID: $($connection.VirtualNetworkId)" -ForegroundColor Gray
        Write-Output-Safe "    Virtual Network Location: $($connection.VirtualNetworkLocation)" -ForegroundColor Gray
        Write-Output-Safe "    Subnet ID: $($connection.SubnetId)" -ForegroundColor Gray
        Write-Output-Safe "    Health Check Status: $($connection.HealthCheckStatus)" -ForegroundColor $(if ($connection.HealthCheckStatus -eq "passed") { "Green" } elseif ($connection.HealthCheckStatus -eq "pending") { "Yellow" } else { "Red" })
        Write-Output-Safe "    Health Check Details: $($connection.HealthCheckStatusDetails)" -ForegroundColor Gray
        Write-Output-Safe "    In Use: $($connection.InUse)" -ForegroundColor Gray
        Write-Output-Safe "    Managed By: $($connection.ManagedBy)" -ForegroundColor Gray
        Write-Output-Safe "    Type: $($connection.Type)" -ForegroundColor Gray
    }
}

# Function to export network connections to CSV format
function Export-NetworkConnectionsToCSV {
    param([array]$Connections)
    
    if (-not $Connections) {
        Write-Output-Safe "No network connections to export" -ForegroundColor Yellow
        return
    }
    
    # Output CSV headers
    Write-Output "Id,DisplayName,SubscriptionId,ConnectionType,SubscriptionName,AdDomainName,AdDomainUsername,OrganizationalUnit,ResourceGroupId,VirtualNetworkId,VirtualNetworkLocation,SubnetId,HealthCheckStatus,HealthCheckStatusDetails,InUse,ManagedBy,Type"
    
    # Output CSV rows
    foreach ($connection in $Connections) {
        $csvRow = @(
            "`"$($connection.Id)`"",
            "`"$($connection.DisplayName)`"",
            "`"$($connection.SubscriptionId)`"",
            "`"$($connection.ConnectionType)`"",
            "`"$($connection.SubscriptionName)`"",
            "`"$($connection.AdDomainName)`"",
            "`"$($connection.AdDomainUsername)`"",
            "`"$($connection.OrganizationalUnit)`"",
            "`"$($connection.ResourceGroupId)`"",
            "`"$($connection.VirtualNetworkId)`"",
            "`"$($connection.VirtualNetworkLocation)`"",
            "`"$($connection.SubnetId)`"",
            "`"$($connection.HealthCheckStatus)`"",
            "`"$($connection.HealthCheckStatusDetails)`"",
            "`"$($connection.InUse)`"",
            "`"$($connection.ManagedBy)`"",
            "`"$($connection.Type)`""
        ) -join ","
        
        Write-Output $csvRow
    }
}

# Function to find policy by name
function Find-PolicyByName {
    param(
        [string]$PolicyName,
        [array]$AllPolicies
    )
    
    $policy = $AllPolicies | Where-Object { $_.DisplayName -eq $PolicyName }
    if (-not $policy) {
        # Try partial match
        $policy = $AllPolicies | Where-Object { $_.DisplayName -like "*$PolicyName*" }
        if ($policy -and $policy.Count -gt 1) {
            Write-Output-Safe "Warning: Multiple policies match '$PolicyName'. Using first match: $($policy[0].DisplayName)" -ForegroundColor Yellow
            $policy = $policy[0]
        }
    }
    
    return $policy
}

# Function to get user's current provisioning policy
function Get-UserCurrentProvisioningPolicy {
    param([string]$UserPrincipalName)
    
    try {
        Write-Output-Safe "Checking user's current Cloud PC and provisioning policy..." -ForegroundColor Yellow
        
        # Get Cloud PCs for the user
        $uri = "https://graph.microsoft.com/beta/deviceManagement/virtualEndpoint/cloudPCs?`$filter=userPrincipalName eq '$UserPrincipalName'"
        $cloudPCs = Invoke-MgGraphRequest -Uri $uri -Method GET
        
        if ($cloudPCs.value.Count -eq 0) {
            Write-Output-Safe "No Cloud PCs found for user: $UserPrincipalName" -ForegroundColor Yellow
            return $null
        }
        
        # Get the most recent Cloud PC (in case there are multiple)
        $latestCloudPC = $cloudPCs.value | Sort-Object lastModifiedDateTime -Descending | Select-Object -First 1
        
        if ($latestCloudPC.provisioningPolicyId) {
            try {
                # Get the full provisioning policy details
                $policyUri = "https://graph.microsoft.com/beta/deviceManagement/virtualEndpoint/provisioningPolicies/$($latestCloudPC.provisioningPolicyId)"
                $policy = Invoke-MgGraphRequest -Uri $policyUri -Method GET
                
                Write-Output-Safe "Found current provisioning policy: $($policy.displayName)" -ForegroundColor Green
                
                return [PSCustomObject]@{
                    PolicyId = $policy.id
                    PolicyName = $policy.displayName
                    CloudPCId = $latestCloudPC.id
                    CloudPCName = $latestCloudPC.displayName
                    CloudPCStatus = $latestCloudPC.status
                }
            }
            catch {
                Write-Output-Safe "Warning: Could not retrieve policy details for ID: $($latestCloudPC.provisioningPolicyId)" -ForegroundColor Yellow
                return [PSCustomObject]@{
                    PolicyId = $latestCloudPC.provisioningPolicyId
                    PolicyName = "Unknown (ID: $($latestCloudPC.provisioningPolicyId))"
                    CloudPCId = $latestCloudPC.id
                    CloudPCName = $latestCloudPC.displayName
                    CloudPCStatus = $latestCloudPC.status
                }
            }
        } else {
            Write-Output-Safe "Cloud PC found but no provisioning policy ID available" -ForegroundColor Yellow
            return $null
        }
    }
    catch {
        Write-Output-Safe "Error getting user's current provisioning policy: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

# Function to find which groups user needs to be removed from
function Get-UserGroupsForPolicy {
    param(
        [string]$UserPrincipalName,
        [string]$PolicyId,
        [array]$AllPolicies
    )
    
    $policy = $AllPolicies | Where-Object { $_.Id -eq $PolicyId }
    if (-not $policy) {
        return @()
    }
    
    $userGroups = @()
    foreach ($group in $policy.AssignedGroups) {
        if ($group.GroupId -eq "AllLicensedUsers" -or $group.GroupId -eq "AllDevices") {
            # Skip built-in assignment types as we can't remove users from these
            continue
        }
        
        try {
            # Check if user is member of this group
            $user = Get-MgUser -Filter "userPrincipalName eq '$UserPrincipalName'" -ErrorAction Stop
            $membership = Get-MgGroupMember -GroupId $group.GroupId -All | Where-Object { $_.Id -eq $user.Id }
            
            if ($membership) {
                $userGroups += $group
                Write-Output-Safe "  User is member of: $($group.GroupName)" -ForegroundColor Gray
            }
        }
        catch {
            Write-Output-Safe "  Warning: Could not check membership for group: $($group.GroupName)" -ForegroundColor Yellow
        }
    }
    
    return $userGroups
}

# Function to wait with progress indicator (automated version)
function Wait-WithProgress {
    $totalSeconds = $Minutes * 60
    $interval = 10  # Update every 10 seconds
    
    Write-Output-Safe "`n$Message..." -ForegroundColor Yellow
    Write-Output-Safe "This may take up to $Minutes minutes for Azure to process the changes." -ForegroundColor Gray
    
    if (-not $Global:SilentMode) {
        for ($i = 0; $i -lt $totalSeconds; $i += $interval) {
            $remainingMinutes = [math]::Round(($totalSeconds - $i) / 60, 1)
            $progressPercent = [math]::Round(($i / $totalSeconds) * 100)
            
            Write-Progress -Activity $Message -Status "Time remaining: $remainingMinutes minutes" -PercentComplete $progressPercent
            Start-Sleep -Seconds $interval
        }
        
        Write-Progress -Activity $Message -Completed
    } else {
        # In silent mode, just wait without progress bar
        Start-Sleep -Seconds $totalSeconds
    }
    
    Write-Output-Safe "Wait period completed. Proceeding with Cloud PC status check..." -ForegroundColor Green
}

# Cloud PC Recovery & Reprovisioning Tool - PART 2 OF 3

# Function to deprovision Cloud PC for single user (automated version)
function Invoke-CloudPCDeprovision {
    param(
        [string]$UserPrincipalName,
        [switch]$AutoConfirm = $false,
        [switch]$AutoEndGracePeriod = $false
    )
    
    try {
        Write-Output-Safe "`nStarting Cloud PC deprovisioning for: $UserPrincipalName" -ForegroundColor Cyan
        Write-Output-Safe "============================================================" -ForegroundColor Cyan
        
        # Get user object
        Write-Output-Safe "Looking up user..." -ForegroundColor Yellow
        $user = Get-MgUser -Filter "userPrincipalName eq '$UserPrincipalName'" -ErrorAction Stop
        
        if (-not $user) {
            Write-Output-Safe "User not found: $UserPrincipalName" -ForegroundColor Red
            return $false
        }
        
        Write-Output-Safe "Found user: $($user.DisplayName) ($($user.Id))" -ForegroundColor Green
        
        # Get user's current provisioning policy
        $currentPolicy = Get-UserCurrentProvisioningPolicy -UserPrincipalName $UserPrincipalName
        
        if (-not $currentPolicy) {
            Write-Output-Safe "No Cloud PC or provisioning policy found for user" -ForegroundColor Yellow
            return $false
        }
        
        Write-Output-Safe "`nCurrent Policy Information:" -ForegroundColor Cyan
        Write-Output-Safe "  Policy: $($currentPolicy.PolicyName)" -ForegroundColor White
        Write-Output-Safe "  Cloud PC: $($currentPolicy.CloudPCName)" -ForegroundColor White
        Write-Output-Safe "  Status: $($currentPolicy.CloudPCStatus)" -ForegroundColor White
        
        # Get all policies to find group memberships
        $allPolicies = Get-CloudPCProvisioningPolicies
        if (-not $allPolicies) {
            Write-Output-Safe "Cannot retrieve provisioning policies" -ForegroundColor Red
            return $false
        }
        
        # Find groups to remove user from
        Write-Output-Safe "`nChecking group memberships for current policy..." -ForegroundColor Yellow
        $groupsToRemoveFrom = Get-UserGroupsForPolicy -UserPrincipalName $UserPrincipalName -PolicyId $currentPolicy.PolicyId -AllPolicies $allPolicies
        
        if ($groupsToRemoveFrom.Count -eq 0) {
            Write-Output-Safe "No group memberships found to remove" -ForegroundColor Yellow
            Write-Output-Safe "User may have been manually assigned or is part of 'All Licensed Users' assignment" -ForegroundColor Yellow
        } else {
            Write-Output-Safe "User will be removed from these groups:" -ForegroundColor Yellow
            foreach ($group in $groupsToRemoveFrom) {
                Write-Output-Safe "  - $($group.GroupName)" -ForegroundColor White
            }
            
            # Confirm removal (skip if AutoConfirm is set)
            if (-not $AutoConfirm -and -not $Global:SilentMode) {
                $confirmRemoval = Read-Host "`nProceed with removing user from these groups? (y/n)"
                if ($confirmRemoval -ne 'y' -and $confirmRemoval -ne 'Y') {
                    Write-Output-Safe "Group removal cancelled by user" -ForegroundColor Yellow
                    return $false
                }
            } else {
                Write-Output-Safe "`nProceeding with group removal (AutoConfirm enabled)..." -ForegroundColor Green
            }
            
            foreach ($group in $groupsToRemoveFrom) {
                try {
                    Write-Output-Safe "Removing user from: $($group.GroupName)..." -ForegroundColor Yellow
                    Remove-MgGroupMemberByRef -GroupId $group.GroupId -DirectoryObjectId $user.Id -ErrorAction Stop
                    Write-Output-Safe "  Successfully removed from $($group.GroupName)" -ForegroundColor Green
                }
                catch {
                    if ($_.Exception.Message -like "*does not exist*") {
                        Write-Output-Safe "  User was not a member of $($group.GroupName)" -ForegroundColor Yellow
                    } else {
                        Write-Output-Safe "  Error removing user from $($group.GroupName): $($_.Exception.Message)" -ForegroundColor Red
                    }
                }
            }
            
            # Wait 5 minutes for Azure to process the group changes
            Write-Output-Safe "`nGroup removal completed. Now waiting for Azure to process the changes..." -ForegroundColor Green
            Wait-WithProgress -Minutes 5 -Message "Waiting for Azure to process group membership changes"
        }
        
        # Check Cloud PC status after group removal and wait period
        Write-Output-Safe "`nChecking Cloud PC status after group changes..." -ForegroundColor Yellow
        $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $UserPrincipalName
        
        if ($cloudPCs) {
            Show-CloudPCStatus -CloudPCs $cloudPCs
            
            # Handle grace period
            $gracePeriodPCs = $cloudPCs | Where-Object { $_.IsInGracePeriod }
            if ($gracePeriodPCs) {
                Write-Output-Safe "`nFound Cloud PCs in grace period." -ForegroundColor Yellow
                
                if ($AutoEndGracePeriod) {
                    Write-Output-Safe "AutoEndGracePeriod enabled - ending grace periods automatically..." -ForegroundColor Green
                    foreach ($pc in $gracePeriodPCs) {
                        $success = End-CloudPCGracePeriod -CloudPCId $pc.Id
                        if ($success) {
                            Write-Output-Safe "Grace period ended for: $($pc.DisplayName)" -ForegroundColor Green
                        }
                    }
                    Write-Output-Safe "`nCloud PC deprovisioning completed!" -ForegroundColor Green
                } else {
                    if (-not $Global:SilentMode) {
                        $endGrace = Read-Host "Do you want to end the grace period to complete deprovisioning? (y/n)"
                        if ($endGrace -eq 'y' -or $endGrace -eq 'Y') {
                            foreach ($pc in $gracePeriodPCs) {
                                $success = End-CloudPCGracePeriod -CloudPCId $pc.Id
                                if ($success) {
                                    Write-Output-Safe "Grace period ended for: $($pc.DisplayName)" -ForegroundColor Green
                                }
                            }
                            Write-Output-Safe "`nCloud PC deprovisioning completed!" -ForegroundColor Green
                        } else {
                            Write-Output-Safe "Grace period maintained. Cloud PC will be deprovisioned automatically when grace period expires." -ForegroundColor Yellow
                        }
                    } else {
                        Write-Output-Safe "Silent mode - grace periods not ended automatically. Use -AutoEndGracePeriod to end automatically." -ForegroundColor Yellow
                    }
                }
            } else {
                Write-Output-Safe "`nCloud PC is not yet in grace period. This may take additional time." -ForegroundColor Yellow
                Write-Output-Safe "You can check again later or the Cloud PC will be automatically deprovisioned when Azure processes the change." -ForegroundColor Gray
            }
        }
        
        Write-Output-Safe "`nDeprovisioning process completed for: $UserPrincipalName" -ForegroundColor Green
        return $true
    }
    catch {
        Write-Output-Safe "Error during deprovisioning: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to deprovision Cloud PCs for multiple users (automated version)
function Invoke-BulkCloudPCDeprovision {
    param(
        [array]$UserPrincipalNames,
        [switch]$AutoConfirm = $false,
        [switch]$AutoEndGracePeriod = $false
    )
    
    Write-Output-Safe "`nStarting Bulk Cloud PC Deprovisioning" -ForegroundColor Cyan
    Write-Output-Safe "============================================================" -ForegroundColor Cyan
    Write-Output-Safe "Users to process: $($UserPrincipalNames.Count)" -ForegroundColor White
    
    $results = @()
    $usersWithGroupChanges = @()
    
    # Phase 1: Remove users from groups
    Write-Output-Safe "`nPhase 1: Removing users from provisioning policy groups..." -ForegroundColor Cyan
    Write-Output-Safe "============================================================" -ForegroundColor Cyan
    
    foreach ($upn in $UserPrincipalNames) {
        Write-Output-Safe "`n--------------------------------------------------" -ForegroundColor Gray
        Write-Output-Safe "Processing: $upn" -ForegroundColor Yellow
        Write-Output-Safe "--------------------------------------------------" -ForegroundColor Gray
        
        $result = [PSCustomObject]@{
            UserPrincipalName = $upn
            GroupRemovalSuccess = $false
            GracePeriodEndSuccess = $false
            Message = ""
            GroupsRemoved = @()
        }
        
        try {
            # Get user object
            $user = Get-MgUser -Filter "userPrincipalName eq '$upn'" -ErrorAction Stop
            if (-not $user) {
                $result.Message = "User not found"
                $results += $result
                continue
            }
            
            # Get user's current provisioning policy
            $currentPolicy = Get-UserCurrentProvisioningPolicy -UserPrincipalName $upn
            if (-not $currentPolicy) {
                $result.Message = "No Cloud PC or provisioning policy found"
                $results += $result
                continue
            }
            
            Write-Output-Safe "Current Policy: $($currentPolicy.PolicyName)" -ForegroundColor White
            
            # Get all policies to find group memberships
            $allPolicies = Get-CloudPCProvisioningPolicies
            if (-not $allPolicies) {
                $result.Message = "Cannot retrieve provisioning policies"
                $results += $result
                continue
            }
            
            # Find groups to remove user from
            $groupsToRemoveFrom = Get-UserGroupsForPolicy -UserPrincipalName $upn -PolicyId $currentPolicy.PolicyId -AllPolicies $allPolicies
            
            if ($groupsToRemoveFrom.Count -eq 0) {
                $result.Message = "No group memberships found to remove"
                $results += $result
                continue
            }
            
            # Remove from groups
            $removedGroups = @()
            foreach ($group in $groupsToRemoveFrom) {
                try {
                    Write-Output-Safe "  Removing from: $($group.GroupName)..." -ForegroundColor Yellow
                    Remove-MgGroupMemberByRef -GroupId $group.GroupId -DirectoryObjectId $user.Id -ErrorAction Stop
                    Write-Output-Safe "    Successfully removed" -ForegroundColor Green
                    $removedGroups += $group.GroupName
                }
                catch {
                    if ($_.Exception.Message -like "*does not exist*") {
                        Write-Output-Safe "    User was not a member" -ForegroundColor Yellow
                    } else {
                        Write-Output-Safe "    Error: $($_.Exception.Message)" -ForegroundColor Red
                    }
                }
            }
            
            if ($removedGroups.Count -gt 0) {
                $result.GroupRemovalSuccess = $true
                $result.GroupsRemoved = $removedGroups
                $usersWithGroupChanges += $upn
                Write-Output-Safe "  Groups removed: $($removedGroups.Count)" -ForegroundColor Green
            }
            
        }
        catch {
            $result.Message = "Error: $($_.Exception.Message)"
            Write-Output-Safe "Error processing $upn : $($_.Exception.Message)" -ForegroundColor Red
        }
        
        $results += $result
    }
    
    # Phase 2: Wait for Azure to process changes (only if there were group changes)
    if ($usersWithGroupChanges.Count -gt 0) {
        Write-Output-Safe "`n============================================================" -ForegroundColor Cyan
        Write-Output-Safe "Phase 2: Waiting for Azure to process group changes..." -ForegroundColor Cyan
        Write-Output-Safe "============================================================" -ForegroundColor Cyan
        Write-Output-Safe "Users with group changes: $($usersWithGroupChanges.Count)" -ForegroundColor White
        
        Wait-WithProgress -Minutes 5 -Message "Waiting for Azure to process group membership changes for all users"
    }
    
    # Phase 3: Check grace periods and optionally end them
    if ($usersWithGroupChanges.Count -gt 0) {
        Write-Output-Safe "`n============================================================" -ForegroundColor Cyan
        Write-Output-Safe "Phase 3: Checking grace periods and ending if requested..." -ForegroundColor Cyan
        Write-Output-Safe "============================================================" -ForegroundColor Cyan
        
        foreach ($upn in $usersWithGroupChanges) {
            Write-Output-Safe "`n--------------------------------------------------" -ForegroundColor Gray
            Write-Output-Safe "Checking grace period for: $upn" -ForegroundColor Yellow
            Write-Output-Safe "--------------------------------------------------" -ForegroundColor Gray
            
            $result = $results | Where-Object { $_.UserPrincipalName -eq $upn }
            
            try {
                $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $upn
                
                if ($cloudPCs) {
                    Show-CloudPCStatus -CloudPCs $cloudPCs
                    
                    $gracePeriodPCs = $cloudPCs | Where-Object { $_.IsInGracePeriod }
                    if ($gracePeriodPCs) {
                        Write-Output-Safe "Found Cloud PCs in grace period for $upn" -ForegroundColor Yellow
                        
                        if ($AutoEndGracePeriod) {
                            Write-Output-Safe "AutoEndGracePeriod enabled - ending grace periods automatically..." -ForegroundColor Green
                            foreach ($pc in $gracePeriodPCs) {
                                $success = End-CloudPCGracePeriod -CloudPCId $pc.Id
                                if ($success) {
                                    Write-Output-Safe "Grace period ended for: $($pc.DisplayName)" -ForegroundColor Green
                                    $result.GracePeriodEndSuccess = $true
                                }
                            }
                        } else {
                            if (-not $Global:SilentMode) {
                                $endGrace = Read-Host "End grace period for $upn? (y/n)"
                                if ($endGrace -eq 'y' -or $endGrace -eq 'Y') {
                                    foreach ($pc in $gracePeriodPCs) {
                                        $success = End-CloudPCGracePeriod -CloudPCId $pc.Id
                                        if ($success) {
                                            Write-Output-Safe "Grace period ended for: $($pc.DisplayName)" -ForegroundColor Green
                                            $result.GracePeriodEndSuccess = $true
                                        }
                                    }
                                }
                            } else {
                                Write-Output-Safe "Silent mode - grace periods not ended. Use -AutoEndGracePeriod to end automatically." -ForegroundColor Yellow
                            }
                        }
                    } else {
                        Write-Output-Safe "No Cloud PCs in grace period yet for $upn" -ForegroundColor Yellow
                        Write-Output-Safe "The Cloud PC may take additional time to enter grace period" -ForegroundColor Gray
                    }
                }
                
                # Update result message
                if ($result.GroupRemovalSuccess -and $result.GracePeriodEndSuccess) {
                    $result.Message = "Fully deprovisioned"
                } elseif ($result.GroupRemovalSuccess) {
                    $result.Message = "Groups removed, grace period pending"
                }
                
            }
            catch {
                Write-Output-Safe "Error checking grace period for $upn : $($_.Exception.Message)" -ForegroundColor Red
                $result.Message += " | Grace period check failed"
            }
        }
    }
    
    # Display final summary
    Write-Output-Safe "`n============================================================" -ForegroundColor Cyan
    Write-Output-Safe "BULK DEPROVISIONING SUMMARY" -ForegroundColor Cyan
    Write-Output-Safe "============================================================" -ForegroundColor Cyan
    
    $groupRemovalSuccessCount = ($results | Where-Object { $_.GroupRemovalSuccess }).Count
    $gracePeriodEndSuccessCount = ($results | Where-Object { $_.GracePeriodEndSuccess }).Count
    $totalUsers = $results.Count
    
    Write-Output-Safe "Total Users Processed: $totalUsers" -ForegroundColor White
    Write-Output-Safe "Group Removals Successful: $groupRemovalSuccessCount" -ForegroundColor Green
    Write-Output-Safe "Grace Periods Ended: $gracePeriodEndSuccessCount" -ForegroundColor Green
    Write-Output-Safe "Failed Operations: $($totalUsers - $groupRemovalSuccessCount)" -ForegroundColor Red
    
    Write-Output-Safe "`nDetailed Results:" -ForegroundColor White
    foreach ($result in $results) {
        $status = if ($result.GroupRemovalSuccess -and $result.GracePeriodEndSuccess) { 
            "FULLY COMPLETE" 
        } elseif ($result.GroupRemovalSuccess) { 
            "GROUPS REMOVED" 
        } else { 
            "FAILED" 
        }
        
        $color = if ($result.GroupRemovalSuccess -and $result.GracePeriodEndSuccess) { 
            "Green" 
        } elseif ($result.GroupRemovalSuccess) { 
            "Yellow" 
        } else { 
            "Red" 
        }
        
        Write-Output-Safe "  [$status] $($result.UserPrincipalName)" -ForegroundColor $color
        if ($result.GroupsRemoved.Count -gt 0) {
            Write-Output-Safe "    Groups removed: $($result.GroupsRemoved -join ', ')" -ForegroundColor Gray
        }
        if ($result.Message) {
            Write-Output-Safe "    Message: $($result.Message)" -ForegroundColor Gray
        }
    }
    
    return $results
}

# Function to move user between groups with policy context (automated version)
function Move-UserBetweenPolicyGroups {
    param(
        [string]$UserPrincipalName,
        [string]$SourcePolicyName,
        [string]$SourceGroupId,
        [string]$TargetPolicyName, 
        [string]$TargetGroupId
    )
    
    try {
        # Get user object
        Write-Output-Safe "Looking up user: $UserPrincipalName..." -ForegroundColor Yellow
        $user = Get-MgUser -Filter "userPrincipalName eq '$UserPrincipalName'" -ErrorAction Stop
        
        if (-not $user) {
            Write-Output-Safe "User not found: $UserPrincipalName" -ForegroundColor Red
            return $false
        }
        
        Write-Output-Safe "Found user: $($user.DisplayName) ($($user.Id))" -ForegroundColor Green
        
        # Show the policy migration context
        if ($SourcePolicyName -and $SourceGroupId) {
            Write-Output-Safe "Moving FROM: $SourcePolicyName (Group ID: $SourceGroupId)" -ForegroundColor Cyan
        }
        Write-Output-Safe "Moving TO: $TargetPolicyName (Group ID: $TargetGroupId)" -ForegroundColor Cyan
        
        # Remove from source group if specified
        if ($SourceGroupId) {
            Write-Output-Safe "Removing user from source provisioning policy group..." -ForegroundColor Yellow
            try {
                Remove-MgGroupMemberByRef -GroupId $SourceGroupId -DirectoryObjectId $user.Id -ErrorAction Stop
                Write-Output-Safe "Successfully removed user from source group" -ForegroundColor Green
            }
            catch {
                if ($_.Exception.Message -like "*does not exist*") {
                    Write-Output-Safe "User was not a member of the source group" -ForegroundColor Yellow
                } else {
                    Write-Output-Safe "Warning: Could not remove user from source group: $($_.Exception.Message)" -ForegroundColor Yellow
                }
            }
        }
        
        # Add to target group
        Write-Output-Safe "Adding user to target provisioning policy group..." -ForegroundColor Yellow
        try {
            New-MgGroupMember -GroupId $TargetGroupId -DirectoryObjectId $user.Id -ErrorAction Stop
            Write-Output-Safe "Successfully added user to target group" -ForegroundColor Green
            return $true
        }
        catch {
            if ($_.Exception.Message -like "*already exists*") {
                Write-Output-Safe "User is already a member of the target group" -ForegroundColor Yellow
                return $true
            } else {
                Write-Output-Safe "Error adding user to target group: $($_.Exception.Message)" -ForegroundColor Red
                return $false
            }
        }
    }
    catch {
        Write-Output-Safe "Error processing user move: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to get user's Cloud PC status
function Get-UserCloudPCStatus {
    param([string]$UserPrincipalName)
    
    try {
        Write-Output-Safe "Checking Cloud PC status for: $UserPrincipalName..." -ForegroundColor Yellow
        
        # Get user object
        $user = Get-MgUser -Filter "userPrincipalName eq '$UserPrincipalName'" -ErrorAction Stop
        
        # Get Cloud PCs for the user
        $uri = "https://graph.microsoft.com/beta/deviceManagement/virtualEndpoint/cloudPCs?`$filter=userPrincipalName eq '$UserPrincipalName'"
        $cloudPCs = Invoke-MgGraphRequest -Uri $uri -Method GET
        
        if ($cloudPCs.value.Count -eq 0) {
            Write-Output-Safe "No Cloud PCs found for user: $UserPrincipalName" -ForegroundColor Yellow
            return $null
        }
        
        $cloudPCList = @()
        foreach ($cloudPC in $cloudPCs.value) {
            $cloudPCInfo = [PSCustomObject]@{
                Id = $cloudPC.id
                DisplayName = $cloudPC.displayName
                Status = $cloudPC.status
                ProvisioningPolicyId = $cloudPC.provisioningPolicyId
                ProvisioningPolicyName = "Unknown"
                GracePeriodEndDateTime = $cloudPC.gracePeriodEndDateTime
                IsInGracePeriod = $false
                LastModifiedDateTime = $cloudPC.lastModifiedDateTime
                UserPrincipalName = $cloudPC.userPrincipalName
            }
            
            # Check if in grace period
            if ($cloudPC.gracePeriodEndDateTime) {
                $gracePeriodEnd = [DateTime]::Parse($cloudPC.gracePeriodEndDateTime)
                $cloudPCInfo.IsInGracePeriod = $gracePeriodEnd -gt (Get-Date)
            }
            
            # Get provisioning policy name
            if ($cloudPC.provisioningPolicyId) {
                try {
                    $policyUri = "https://graph.microsoft.com/beta/deviceManagement/virtualEndpoint/provisioningPolicies/$($cloudPC.provisioningPolicyId)"
                    $policy = Invoke-MgGraphRequest -Uri $policyUri -Method GET
                    $cloudPCInfo.ProvisioningPolicyName = $policy.displayName
                }
                catch {
                    $cloudPCInfo.ProvisioningPolicyName = "Policy not found or access denied"
                }
            }
            
            $cloudPCList += $cloudPCInfo
        }
        
        return $cloudPCList
    }
    catch {
        Write-Output-Safe "Error getting Cloud PC status: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

# Function to display Cloud PC status
function Show-CloudPCStatus {
    param([array]$CloudPCs)
    
    if (-not $CloudPCs -or $CloudPCs.Count -eq 0) {
        Write-Output-Safe "No Cloud PCs to display" -ForegroundColor Yellow
        return
    }
    
    Write-Output-Safe "`nCloud PC Status:" -ForegroundColor Cyan
    Write-Output-Safe "==============================" -ForegroundColor Cyan
    
    foreach ($cloudPC in $CloudPCs) {
        Write-Output-Safe "`nCloud PC: $($cloudPC.DisplayName)" -ForegroundColor Yellow
        Write-Output-Safe "  Status: $($cloudPC.Status)" -ForegroundColor White
        Write-Output-Safe "  Provisioning Policy: $($cloudPC.ProvisioningPolicyName)" -ForegroundColor White
        Write-Output-Safe "  User: $($cloudPC.UserPrincipalName)" -ForegroundColor White
        Write-Output-Safe "  Last Modified: $($cloudPC.LastModifiedDateTime)" -ForegroundColor Gray
        
        if ($cloudPC.IsInGracePeriod) {
            Write-Output-Safe "  Grace Period: Active (Ends: $($cloudPC.GracePeriodEndDateTime))" -ForegroundColor Red
        } elseif ($cloudPC.GracePeriodEndDateTime) {
            Write-Output-Safe "  Grace Period: Ended ($($cloudPC.GracePeriodEndDateTime))" -ForegroundColor Green
        } else {
            Write-Output-Safe "  Grace Period: Not applicable" -ForegroundColor Gray
        }
    }
}

# Function to end grace period
function End-CloudPCGracePeriod {
    param([string]$CloudPCId)
    
    try {
        Write-Output-Safe "Ending grace period for Cloud PC: $CloudPCId..." -ForegroundColor Yellow
        
        $uri = "https://graph.microsoft.com/beta/deviceManagement/virtualEndpoint/cloudPCs/$CloudPCId/endGracePeriod"
        Invoke-MgGraphRequest -Uri $uri -Method POST
        
        Write-Output-Safe "Grace period ended successfully" -ForegroundColor Green
        return $true
    }
    catch {
        Write-Output-Safe "Error ending grace period: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

# Function to wait for provisioning
function Wait-ForProvisioning {
    param(
        [string]$UserPrincipalName,
        [int]$TimeoutMinutes = 30
    )
    
    Write-Output-Safe "Monitoring provisioning status for $UserPrincipalName..." -ForegroundColor Yellow
    Write-Output-Safe "Timeout set to $TimeoutMinutes minutes" -ForegroundColor Gray
    
    $startTime = Get-Date
    $timeout = $startTime.AddMinutes($TimeoutMinutes)
    
    do {
        $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $UserPrincipalName
        
        if ($cloudPCs) {
            $provisionedPC = $cloudPCs | Where-Object { $_.Status -eq "Provisioned" }
            if ($provisionedPC) {
                Write-Output-Safe "`nProvisioning completed!" -ForegroundColor Green
                Show-CloudPCStatus -CloudPCs @($provisionedPC)
                return $provisionedPC
            }
        }
        
        $elapsed = (Get-Date) - $startTime
        Write-Output-Safe "  Elapsed: $([math]::Round($elapsed.TotalMinutes, 1)) minutes - Status: Provisioning..." -ForegroundColor Yellow
        Start-Sleep -Seconds 30
        
    } while ((Get-Date) -lt $timeout)
    
    Write-Output-Safe "`nTimeout reached. Provisioning may still be in progress." -ForegroundColor Yellow
    return $null
}

# Cloud PC Recovery & Reprovisioning Tool - PART 3 OF 3

# Main menu function (interactive mode only)
function Show-MainMenu {
    Write-Host "`nMain Menu:" -ForegroundColor Cyan
    Write-Host "==========" -ForegroundColor Cyan
    Write-Host "1. View all Provisioning Policies and Group Assignments"
    Write-Host "2. View all Azure Network Connections" -ForegroundColor Cyan
    Write-Host "3. Move User Between Provisioning Policies"
    Write-Host "4. Move User Between Provisioning Policies (Auto-Discovery)" -ForegroundColor Green
    Write-Host "5. Check User Cloud PC Status"
    Write-Host "6. End Grace Period for Cloud PC"
# Cloud PC Recovery & Reprovisioning Tool - PART 3 OF 3

# Main menu function (interactive mode only)
function Show-MainMenu {
    Write-Host "`nMain Menu:" -ForegroundColor Cyan
    Write-Host "==========" -ForegroundColor Cyan
    Write-Host "1. View all Provisioning Policies and Group Assignments"
    Write-Host "2. View all Azure Network Connections" -ForegroundColor Cyan
    Write-Host "3. Move User Between Provisioning Policies"
    Write-Host "4. Move User Between Provisioning Policies (Auto-Discovery)" -ForegroundColor Green
    Write-Host "5. Check User Cloud PC Status"
    Write-Host "6. End Grace Period for Cloud PC"
    Write-Host "7. Monitor New Cloud PC Provisioning"
    Write-Host "8. Complete Recovery Workflow"
    Write-Host "9. Deprovision Cloud PC (Single User)" -ForegroundColor Red
    Write-Host "10. Deprovision Cloud PCs (Multiple Users)" -ForegroundColor Red
    Write-Host "11. Disconnect and Exit"
    Write-Host ""
}

# Function to show help
function Show-Help {
    Write-Host "`nCloud PC Recovery & Reprovisioning Tool - Automated Mode" -ForegroundColor Cyan
    Write-Host "============================================================" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "USAGE:" -ForegroundColor Yellow
    Write-Host "  .\CloudPCTool.ps1 -Operation <OperationType> [additional parameters]" -ForegroundColor White
    Write-Host ""
    Write-Host "OPERATIONS:" -ForegroundColor Yellow
    Write-Host "  ViewPolicies          - Display all provisioning policies"
    Write-Host "  ViewNetworkConnections - Display all Azure Network Connections"
    Write-Host "  CheckStatus          - Check Cloud PC status for user(s)"
    Write-Host "  DeprovisionSingle    - Deprovision single user's Cloud PC"
    Write-Host "  DeprovisionBulk      - Deprovision multiple users' Cloud PCs"
    Write-Host "  MoveUserAuto         - Move user between policies (auto-discovery)"
    Write-Host "  EndGracePeriod       - End grace period for user's Cloud PC"
    Write-Host "  MonitorProvisioning  - Monitor new Cloud PC provisioning"
    Write-Host "  Interactive          - Run in interactive mode (default)"
    Write-Host ""
    Write-Host "PARAMETERS:" -ForegroundColor Yellow
    Write-Host "  -UserPrincipalName    Single user email address"
    Write-Host "  -UserList            Array of user email addresses"
    Write-Host "  -UserListFile        Path to CSV or TXT file with user list"
    Write-Host "  -TargetPolicyName    Target provisioning policy name"
    Write-Host "  -AutoConfirm         Skip confirmation prompts"
    Write-Host "  -AutoEndGracePeriod  Automatically end grace periods"
    Write-Host "  -Silent              Suppress console output"
    Write-Host "  -TimeoutMinutes      Timeout for monitoring operations (default: 30)"
    Write-Host ""
    Write-Host "EXAMPLES:" -ForegroundColor Yellow
    Write-Host "  # View all policies"
    Write-Host "  .\CloudPCTool.ps1 -Operation ViewPolicies"
    Write-Host ""
    Write-Host "  # View all network connections"
    Write-Host "  .\CloudPCTool.ps1 -Operation ViewNetworkConnections"
    Write-Host ""
    Write-Host "  # Export network connections to CSV"
    Write-Host "  .\CloudPCTool.ps1 -Operation ViewNetworkConnections -Silent > network_connections.csv"
    Write-Host ""
    Write-Host "  # Check status for single user"
    Write-Host "  .\CloudPCTool.ps1 -Operation CheckStatus -UserPrincipalName user@domain.com"
    Write-Host ""
    Write-Host "  # Deprovision single user with auto-confirmation"
    Write-Host "  .\CloudPCTool.ps1 -Operation DeprovisionSingle -UserPrincipalName user@domain.com -AutoConfirm -AutoEndGracePeriod"
    Write-Host ""
    Write-Host "  # Bulk deprovision from CSV file"
    Write-Host "  .\CloudPCTool.ps1 -Operation DeprovisionBulk -UserListFile 'C:\users.csv' -AutoConfirm -AutoEndGracePeriod -Silent"
    Write-Host ""
    Write-Host "  # Move user to specific policy"
    Write-Host "  .\CloudPCTool.ps1 -Operation MoveUserAuto -UserPrincipalName user@domain.com -TargetPolicyName 'Standard Policy'"
    Write-Host ""
    Write-Host "CSV FILE FORMAT:" -ForegroundColor Yellow
    Write-Host "  The CSV file should have a column with user email addresses."
    Write-Host "  Supported column names: UPN, UserPrincipalName, Email, or the first column"
    Write-Host ""
}

# Main automation logic
function Invoke-AutomatedOperation {
    param(
        [string]$Operation,
        [string]$UserPrincipalName,
        [string]$UserListFile,
        [string[]]$UserList,
        [string]$TargetPolicyName,
        [switch]$AutoConfirm,
        [switch]$AutoEndGracePeriod,
        [int]$TimeoutMinutes
    )
    
    switch ($Operation.ToLower()) {
        "viewpolicies" {
            Write-Output-Safe "=== VIEW PROVISIONING POLICIES ===" -ForegroundColor Cyan
            $policies = Get-CloudPCProvisioningPolicies
            Show-ProvisioningPolicies -Policies $policies
            return $true
        }
        
        "viewnetworkconnections" {
            Write-Output-Safe "=== VIEW AZURE NETWORK CONNECTIONS ===" -ForegroundColor Cyan
            $connections = Get-AzureNetworkConnections
            
            if ($Global:SilentMode) {
                # In silent mode, output CSV format for easy redirection
                Export-NetworkConnectionsToCSV -Connections $connections
            } else {
                # In normal mode, show formatted output
                Show-NetworkConnections -Connections $connections
            }
            return $true
        }
        
        "checkstatus" {
            Write-Output-Safe "=== CHECK CLOUD PC STATUS ===" -ForegroundColor Cyan
            
            if ($UserPrincipalName) {
                $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $UserPrincipalName
                Show-CloudPCStatus -CloudPCs $cloudPCs
                return $true
            } 
            elseif ($UserListFile) {
                $users = Get-UsersFromFile -FilePath $UserListFile
                if (-not $users) { return $false }
                
                foreach ($user in $users) {
                    Write-Output-Safe "`n--------------------------------------------------" -ForegroundColor Gray
                    Write-Output-Safe "Checking status for: $user" -ForegroundColor Yellow
                    $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $user
                    Show-CloudPCStatus -CloudPCs $cloudPCs
                }
                return $true
            }
            elseif ($UserList) {
                foreach ($user in $UserList) {
                    Write-Output-Safe "`n--------------------------------------------------" -ForegroundColor Gray
                    Write-Output-Safe "Checking status for: $user" -ForegroundColor Yellow
                    $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $user
                    Show-CloudPCStatus -CloudPCs $cloudPCs
                }
                return $true
            }
            else {
                Write-Output-Safe "Error: Must specify -UserPrincipalName, -UserList, or -UserListFile" -ForegroundColor Red
                return $false
            }
        }
        
        "deprovisionsingle" {
            Write-Output-Safe "=== DEPROVISION SINGLE USER ===" -ForegroundColor Red
            
            if (-not $UserPrincipalName) {
                Write-Output-Safe "Error: Must specify -UserPrincipalName for single user deprovisioning" -ForegroundColor Red
                return $false
            }
            
            if (-not $AutoConfirm -and -not $Global:SilentMode) {
                Write-Output-Safe "`nWARNING: This will deprovision the user's Cloud PC!" -ForegroundColor Yellow
                Write-Output-Safe "This action will result in data loss if not backed up." -ForegroundColor Yellow
                $confirm = Read-Host "Are you sure you want to proceed? (type 'YES' to confirm)"
                if ($confirm -ne 'YES') {
                    Write-Output-Safe "Operation cancelled" -ForegroundColor Green
                    return $false
                }
            }
            
            $result = Invoke-CloudPCDeprovision -UserPrincipalName $UserPrincipalName -AutoConfirm:$AutoConfirm -AutoEndGracePeriod:$AutoEndGracePeriod
            return $result
        }
        
        "deprovisionbulk" {
            Write-Output-Safe "=== BULK DEPROVISION USERS ===" -ForegroundColor Red
            
            $users = @()
            if ($UserListFile) {
                $users = Get-UsersFromFile -FilePath $UserListFile
                if (-not $users) { return $false }
            }
            elseif ($UserList) {
                $users = $UserList
            }
            else {
                Write-Output-Safe "Error: Must specify -UserList or -UserListFile for bulk deprovisioning" -ForegroundColor Red
                return $false
            }
            
            Write-Output-Safe "Users to deprovision: $($users.Count)" -ForegroundColor White
            
            if (-not $AutoConfirm -and -not $Global:SilentMode) {
                Write-Output-Safe "`nWARNING: This will deprovision Cloud PCs for $($users.Count) users!" -ForegroundColor Yellow
                Write-Output-Safe "This action will result in data loss if not backed up." -ForegroundColor Yellow
                $confirm = Read-Host "Are you sure you want to proceed? (type 'YES' to confirm)"
                if ($confirm -ne 'YES') {
                    Write-Output-Safe "Operation cancelled" -ForegroundColor Green
                    return $false
                }
            }
            
            $results = Invoke-BulkCloudPCDeprovision -UserPrincipalNames $users -AutoConfirm:$AutoConfirm -AutoEndGracePeriod:$AutoEndGracePeriod
            return ($results | Where-Object { $_.GroupRemovalSuccess }).Count -gt 0
        }
        
        "moveuserauto" {
            Write-Output-Safe "=== MOVE USER BETWEEN POLICIES (AUTO-DISCOVERY) ===" -ForegroundColor Cyan
            
            if (-not $UserPrincipalName) {
                Write-Output-Safe "Error: Must specify -UserPrincipalName for user move operation" -ForegroundColor Red
                return $false
            }
            
            if (-not $TargetPolicyName) {
                Write-Output-Safe "Error: Must specify -TargetPolicyName for user move operation" -ForegroundColor Red
                return $false
            }
            
            # Get user's current provisioning policy
            $currentPolicy = Get-UserCurrentProvisioningPolicy -UserPrincipalName $UserPrincipalName
            if (-not $currentPolicy) {
                Write-Output-Safe "Could not determine user's current provisioning policy" -ForegroundColor Yellow
                return $false
            }
            
            Write-Output-Safe "Current Policy: $($currentPolicy.PolicyName)" -ForegroundColor White
            Write-Output-Safe "Target Policy: $TargetPolicyName" -ForegroundColor White
            
            # Get all policies
            $policies = Get-CloudPCProvisioningPolicies
            if (-not $policies) {
                Write-Output-Safe "Cannot proceed without provisioning policies" -ForegroundColor Red
                return $false
            }
            
            # Find target policy
            $targetPolicy = Find-PolicyByName -PolicyName $TargetPolicyName -AllPolicies $policies
            if (-not $targetPolicy) {
                Write-Output-Safe "Target policy '$TargetPolicyName' not found" -ForegroundColor Red
                Write-Output-Safe "Available policies:" -ForegroundColor Yellow
                foreach ($policy in $policies) {
                    Write-Output-Safe "  - $($policy.DisplayName)" -ForegroundColor White
                }
                return $false
            }
            
            # Get target group (use first group if multiple)
            $targetGroupId = $null
            if ($targetPolicy.AssignedGroups.Count -eq 1) {
                $targetGroupId = $targetPolicy.AssignedGroups[0].GroupId
            } elseif ($targetPolicy.AssignedGroups.Count -gt 1) {
                $targetGroupId = $targetPolicy.AssignedGroups[0].GroupId
                Write-Output-Safe "Multiple groups found for target policy. Using first group: $($targetPolicy.AssignedGroups[0].GroupName)" -ForegroundColor Yellow
            } else {
                Write-Output-Safe "No groups assigned to target policy" -ForegroundColor Red
                return $false
            }
            
            # Get source groups for removal
            $sourceGroupsToRemoveFrom = Get-UserGroupsForPolicy -UserPrincipalName $UserPrincipalName -PolicyId $currentPolicy.PolicyId -AllPolicies $policies
            
            # Get user object
            try {
                $user = Get-MgUser -Filter "userPrincipalName eq '$UserPrincipalName'" -ErrorAction Stop
            }
            catch {
                Write-Output-Safe "Error finding user: $($_.Exception.Message)" -ForegroundColor Red
                return $false
            }
            
            # Remove from source groups
            foreach ($sourceGroup in $sourceGroupsToRemoveFrom) {
                try {
                    Write-Output-Safe "Removing user from: $($sourceGroup.GroupName)..." -ForegroundColor Yellow
                    Remove-MgGroupMemberByRef -GroupId $sourceGroup.GroupId -DirectoryObjectId $user.Id -ErrorAction Stop
                    Write-Output-Safe "  Successfully removed from $($sourceGroup.GroupName)" -ForegroundColor Green
                }
                catch {
                    if ($_.Exception.Message -like "*does not exist*") {
                        Write-Output-Safe "  User was not a member of $($sourceGroup.GroupName)" -ForegroundColor Yellow
                    } else {
                        Write-Output-Safe "  Warning: Could not remove user from $($sourceGroup.GroupName): $($_.Exception.Message)" -ForegroundColor Yellow
                    }
                }
            }
            
            # Add to target group
            try {
                Write-Output-Safe "Adding user to target group..." -ForegroundColor Yellow
                New-MgGroupMember -GroupId $targetGroupId -DirectoryObjectId $user.Id -ErrorAction Stop
                Write-Output-Safe "Successfully added user to target policy group" -ForegroundColor Green
                
                Write-Output-Safe "`nPolicy migration completed successfully!" -ForegroundColor Green
                Write-Output-Safe "FROM: $($currentPolicy.PolicyName)" -ForegroundColor Cyan
                Write-Output-Safe "TO: $($targetPolicy.DisplayName)" -ForegroundColor Cyan
                return $true
            }
            catch {
                if ($_.Exception.Message -like "*already exists*") {
                    Write-Output-Safe "User is already a member of the target group" -ForegroundColor Yellow
                    Write-Output-Safe "`nPolicy migration completed!" -ForegroundColor Green
                    return $true
                } else {
                    Write-Output-Safe "Error adding user to target group: $($_.Exception.Message)" -ForegroundColor Red
                    return $false
                }
            }
        }
        
        "endgraceperiod" {
            Write-Output-Safe "=== END GRACE PERIOD ===" -ForegroundColor Cyan
            
            if (-not $UserPrincipalName) {
                Write-Output-Safe "Error: Must specify -UserPrincipalName for grace period operation" -ForegroundColor Red
                return $false
            }
            
            $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $UserPrincipalName
            if (-not $cloudPCs) {
                Write-Output-Safe "No Cloud PCs found for user" -ForegroundColor Yellow
                return $false
            }
            
            Show-CloudPCStatus -CloudPCs $cloudPCs
            $gracePeriodPCs = $cloudPCs | Where-Object { $_.IsInGracePeriod }
            
            if (-not $gracePeriodPCs) {
                Write-Output-Safe "No Cloud PCs in grace period found" -ForegroundColor Yellow
                return $false
            }
            
            foreach ($pc in $gracePeriodPCs) {
                $success = End-CloudPCGracePeriod -CloudPCId $pc.Id
                if ($success) {
                    Write-Output-Safe "Grace period ended for: $($pc.DisplayName)" -ForegroundColor Green
                }
            }
            return $true
        }
        
        "monitorprovisioning" {
            Write-Output-Safe "=== MONITOR PROVISIONING ===" -ForegroundColor Cyan
            
            if (-not $UserPrincipalName) {
                Write-Output-Safe "Error: Must specify -UserPrincipalName for monitoring operation" -ForegroundColor Red
                return $false
            }
            
            $result = Wait-ForProvisioning -UserPrincipalName $UserPrincipalName -TimeoutMinutes $TimeoutMinutes
            return $result -ne $null
        }
        
        default {
            Write-Output-Safe "Error: Unknown operation '$Operation'" -ForegroundColor Red
            Show-Help
            return $false
        }
    }
}

# Main script execution
Show-Banner

# Check if required modules are available
try {
    Get-Module Microsoft.Graph.Authentication -ListAvailable | Out-Null
}
catch {
    Write-Output-Safe "Microsoft Graph PowerShell modules are required but not found." -ForegroundColor Red
    Write-Output-Safe "Please install using: Install-Module Microsoft.Graph -Scope CurrentUser" -ForegroundColor Yellow
    exit 1
}

# Show help if requested
if ($Operation -eq "Help" -or $Operation -eq "?" -or $args -contains "-Help" -or $args -contains "-?") {
    Show-Help
    exit 0
}

# Connect to Microsoft Graph
if (-not (Connect-ToMicrosoftGraph -TenantId $TenantId -ClientId $ClientId -ClientSecret $ClientSecret)) {
    exit 1
}

# Determine execution mode
if ($Operation -eq "Interactive" -or (-not $Operation)) {
    # Interactive mode - run original menu system
    Write-Output-Safe "Running in Interactive Mode" -ForegroundColor Green
    Write-Output-Safe "Use -Operation parameter to run in automated mode" -ForegroundColor Gray
    Write-Output-Safe ""
    
    # Main application loop
    do {
        Show-MainMenu
        $choice = Read-Host "Select an option (1-11)"
        
        switch ($choice) {
            "1" {
                $policies = Get-CloudPCProvisioningPolicies
                Show-ProvisioningPolicies -Policies $policies
                Read-Host "`nPress Enter to continue"
            }
            
            "2" {
                Write-Host "`nView Azure Network Connections" -ForegroundColor Cyan
                Write-Host "============================================================" -ForegroundColor Cyan
                
                $connections = Get-AzureNetworkConnections
                Show-NetworkConnections -Connections $connections
                Read-Host "`nPress Enter to continue"
            }
            
            "3" {
                Write-Host "`nMove User Between Provisioning Policies" -ForegroundColor Cyan
                Write-Host "============================================================" -ForegroundColor Cyan
                
                Write-Host "Interactive move user functionality - same as original script" -ForegroundColor Yellow
                Read-Host "`nPress Enter to continue"
            }
            
            "4" {
                Write-Host "`nMove User Between Provisioning Policies (Auto-Discovery)" -ForegroundColor Cyan
                Write-Host "============================================================" -ForegroundColor Cyan
                
                Write-Host "Interactive auto-discovery functionality - same as original script" -ForegroundColor Yellow
                Read-Host "`nPress Enter to continue"
            }
            
            "5" {
                Write-Host "`nCheck User Cloud PC Status" -ForegroundColor Cyan
                Write-Host "============================================================" -ForegroundColor Cyan
                
                $userPrincipalName = Read-Host "Enter user's email address (UPN)"
                $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $userPrincipalName
                Show-CloudPCStatus -CloudPCs $cloudPCs
                Read-Host "`nPress Enter to continue"
            }
            
            "6" {
                Write-Host "`nEnd Grace Period for Cloud PC" -ForegroundColor Cyan
                Write-Host "============================================================" -ForegroundColor Cyan
                
                $userPrincipalName = Read-Host "Enter user's email address (UPN)"
                $cloudPCs = Get-UserCloudPCStatus -UserPrincipalName $userPrincipalName
                
                if ($cloudPCs) {
                    Show-CloudPCStatus -CloudPCs $cloudPCs
                    $gracePeriodPCs = $cloudPCs | Where-Object { $_.IsInGracePeriod }
                    
                    if ($gracePeriodPCs) {
                        foreach ($pc in $gracePeriodPCs) {
                            $confirm = Read-Host "`nEnd grace period for '$($pc.DisplayName)'? (y/n)"
                            if ($confirm -eq 'y' -or $confirm -eq 'Y') {
                                End-CloudPCGracePeriod -CloudPCId $pc.Id
                            }
                        }
                    } else {
                        Write-Host "No Cloud PCs in grace period found" -ForegroundColor Yellow
                    }
                }
                Read-Host "`nPress Enter to continue"
            }
            
            "7" {
                Write-Host "`nMonitor New Cloud PC Provisioning" -ForegroundColor Cyan
                Write-Host "============================================================" -ForegroundColor Cyan
                
                $userPrincipalName = Read-Host "Enter user's email address (UPN)"
                $timeoutMinutes = Read-Host "Enter timeout in minutes (default: 30)"
                if (-not $timeoutMinutes -or -not [int]::TryParse($timeoutMinutes, [ref]$null)) {
                    $timeoutMinutes = 30
                }
                
                Wait-ForProvisioning -UserPrincipalName $userPrincipalName -TimeoutMinutes ([int]$timeoutMinutes)
                Read-Host "`nPress Enter to continue"
            }
            
            "8" {
                Write-Host "`nComplete Recovery Workflow" -ForegroundColor Cyan
                Write-Host "============================================================" -ForegroundColor Cyan
                
                Write-Host "Interactive recovery workflow functionality - same as original script" -ForegroundColor Yellow
                Read-Host "`nPress Enter to continue"
            }
            
            "9" {
                Write-Host "`nDeprovision Cloud PC (Single User)" -ForegroundColor Red
                Write-Host "============================================================" -ForegroundColor Red
                
                $userPrincipalName = Read-Host "Enter user's email address (UPN)"
                if (-not $userPrincipalName) {
                    Write-Host "Invalid user principal name" -ForegroundColor Red
                    Read-Host "`nPress Enter to continue"
                    continue
                }
                
                # Confirmation prompt
                Write-Host "`nWARNING: This will deprovision the user's Cloud PC!" -ForegroundColor Yellow
                Write-Host "This action will:" -ForegroundColor Yellow
                Write-Host "- Remove user from provisioning policy groups" -ForegroundColor Yellow
                Write-Host "- Wait 5 minutes for Azure to process the changes" -ForegroundColor Yellow
                Write-Host "- Optionally end grace period to complete deprovisioning" -ForegroundColor Yellow
                Write-Host "- Result in data loss if not backed up" -ForegroundColor Yellow
                
                $confirm = Read-Host "`nAre you sure you want to proceed? (type 'YES' to confirm)"
                if ($confirm -ne 'YES') {
                    Write-Host "Deprovisioning cancelled" -ForegroundColor Green
                    Read-Host "`nPress Enter to continue"
                    continue
                }
                
                $result = Invoke-CloudPCDeprovision -UserPrincipalName $userPrincipalName
                
                if ($result) {
                    Write-Host "`nCloud PC deprovisioning completed successfully!" -ForegroundColor Green
                } else {
                    Write-Host "`nCloud PC deprovisioning failed or was incomplete" -ForegroundColor Red
                }
                
                Read-Host "`nPress Enter to continue"
            }
            
            "10" {
                Write-Host "`nDeprovision Cloud PCs (Multiple Users)" -ForegroundColor Red
                Write-Host "============================================================" -ForegroundColor Red
                
                Write-Host "Enter user email addresses (UPNs). Enter blank line when done:" -ForegroundColor Yellow
                $userList = @()
                do {
                    $upn = Read-Host "User $($userList.Count + 1) UPN (or press Enter to finish)"
                    if ($upn) {
                        $userList += $upn.Trim()
                    }
                } while ($upn)
                
                if ($userList.Count -eq 0) {
                    Write-Host "No users provided" -ForegroundColor Yellow
                    Read-Host "`nPress Enter to continue"
                    continue
                }
                
                Write-Host "`nUsers to deprovision:" -ForegroundColor White
                for ($i = 0; $i -lt $userList.Count; $i++) {
                    Write-Host "  $($i + 1). $($userList[$i])" -ForegroundColor White
                }
                
                # Confirmation prompt
                Write-Host "`nWARNING: This will deprovision Cloud PCs for $($userList.Count) users!" -ForegroundColor Yellow
                Write-Host "This action will:" -ForegroundColor Yellow
                Write-Host "- Remove users from provisioning policy groups" -ForegroundColor Yellow
                Write-Host "- Wait 5 minutes for Azure to process the changes" -ForegroundColor Yellow
                Write-Host "- Optionally end grace periods to complete deprovisioning" -ForegroundColor Yellow
                Write-Host "- Result in data loss if not backed up" -ForegroundColor Yellow
                
                $confirm = Read-Host "`nAre you sure you want to proceed? (type 'YES' to confirm)"
                if ($confirm -ne 'YES') {
                    Write-Host "Bulk deprovisioning cancelled" -ForegroundColor Green
                    Read-Host "`nPress Enter to continue"
                    continue
                }
                
                $results = Invoke-BulkCloudPCDeprovision -UserPrincipalNames $userList
                
                Write-Host "`nBulk deprovisioning operation completed!" -ForegroundColor Green
                Read-Host "`nPress Enter to continue"
            }
            
            "11" {
                Write-Host "`nDisconnecting from Microsoft Graph..." -ForegroundColor Yellow
                Disconnect-MgGraph
                Write-Host "Goodbye!" -ForegroundColor Green
                exit
            }
            
            default {
                Write-Host "Invalid option. Please select 1-11." -ForegroundColor Red
                Start-Sleep -Seconds 2
            }
        }
        
    } while ($choice -ne "11")
} else {
    # Automated mode
    Write-Output-Safe "Running in Automated Mode: $Operation" -ForegroundColor Green
    
    $success = Invoke-AutomatedOperation -Operation $Operation -UserPrincipalName $UserPrincipalName -UserListFile $UserListFile -UserList $UserList -TargetPolicyName $TargetPolicyName -AutoConfirm:$AutoConfirm -AutoEndGracePeriod:$AutoEndGracePeriod -TimeoutMinutes $TimeoutMinutes
    
    # Disconnect from Graph
    Disconnect-MgGraph
    
    # Exit with appropriate code
    if ($success) {
        Write-Output-Safe "`nOperation completed successfully" -ForegroundColor Green
        exit 0
    } else {
        Write-Output-Safe "`nOperation failed or completed with errors" -ForegroundColor Red
        exit 1
    }
}
